# Define a binary serializer using Treetop parser
# https://github.com/nathansobo/treetop
# https://www.rubydoc.info/gems/treetop/1.6.11
# https://cjheath.github.io/treetop/
# http://thingsaaronmade.com/blog/a-quick-intro-to-writing-a-parser-using-treetop.html
# https://morioh.com/p/c601072f2066

# see example in fixtures/files/binary_serializer.tt

# External functions
# Device.precondition_vocabulary(attr)

# to compile the grammar
# tt lib/json2bits/configurator.tt -f

#require_relative "codecs"

grammar Configurator

  rule configuration
    lines:(line space? eol+)+ {
        def value
            lines.elements.inject(Codecs.new) do |codecs, elt| 
              codec = elt.line.value
              codecs.add_codec(codec)
              codecs
            end
        end
    }
  end  

  rule line
    space? key space codec s:statics? c:comment? {
        def value
          parameters = { 
                key: key.value,
                comment: (c.text_value.empty? ? "" : c.value),
                statics: (s.text_value.empty? ? {} : s.value)
            }
          parameters.merge!(codec.value)
          codec_type = parameters.delete(:codec_type)
          Object.const_get(codec_type).new(**parameters)
        end
    }
  end

  rule comment
    space* "//" space* (!eol .)* {
      def value
        text_value
      end
    }
  end

  rule codec
    codec_boolean / codec_integer / codec_float / codec_hexa / codec_symbol / codec_void / codec_sequence / codec_alias / codec_array / codec_xor / codec_list
  end

  rule codec_boolean 
    "BOOLEAN" {
        def value
          {codec_type: "CodecBoolean"} 
        end
    }
  end

  rule codec_integer 
    "INTEGER" "(" nb_bit:integer ")" {
        def value
          {codec_type: "CodecInteger", nb_bit: nb_bit.value} 
        end
    }
  end

  rule codec_float 
    "FLOAT" "(" nb_bit:integer spl min:float spl max:float ")" {
        def value
          {codec_type: "CodecFloat", nb_bit: nb_bit.value, min_float: min.value, max_float: max.value} 
        end
    }
  end

  rule codec_hexa 
    "HEXA" "(" nb_bytes:integer ")" {
        def value
          {codec_type: "CodecHexa", nb_bytes: nb_bytes.value } 
        end
    }
  end


  rule codec_symbol 
    "SYMBOL" "(" nb_bit:integer spl keys ")" {
        def value
          {codec_type: "CodecSymbol", nb_bit: nb_bit.value, symbols: keys.value } 
        end
    }
  end

  rule codec_void 
    "VOID" {
        def value
          {codec_type: "CodecVoid" } 
        end
    }
  end

  rule codec_sequence
    "SEQUENCE" "(" keys ")" {
        def value
          {codec_type: "CodecSequence", keys: keys.value } 
        end
    }
  end

  rule codec_alias
    "ALIAS" "(" key ")" {
        def value
          {codec_type: "CodecAlias", target_key: key.value } 
        end
    }
  end

  rule codec_array
    "ARRAY" "(" nb_bit:integer spl item_key:key ")" {
        def value
          {codec_type: "CodecArray", nb_bit: nb_bit.value, item_key: item_key.value }
        end
    }
  end

  rule codec_list
    "LIST(" key ")" {
      def value
        {
        codec_type: "CodecList", 
        item_key: key.value, 
        }
      end
    }
  end


  rule codec_xor
    "XOR(" integer spl "[" loose_space b:binary_key bs:(spl binary_key)* "]" loose_space ps:(spl key)* ")" {
      def value
        {
          codec_type: "CodecXor", 
          nb_bit_binary_key: integer.value,
          binary_keys: bs.elements.inject(b.value) { |h, elt| h.merge!(elt.binary_key.value) }
          prefix_keys: ps.elements.inject([]) { |l, elt| l << elt.key.value }
        }
      end
    }
  end

  rule key
    [a-zA-Z0-9_]+ { 
        def value 
            text_value 
        end 
    }
  end

  rule keys 
    f:key s:(spl key)* {
        def value 
            s.elements.inject([f.value]) { |l, elt| l << elt.key.value }
        end
    }
  end

  rule static_value
    float / integer / hexa / boolean / key 
  end

  rule static_key_value
    key s:("=" static_value)? { 
        def value 
            k = key.value 
            v = s.text_value.empty? ? true : s.static_value.value
            { k => v }
        end 
    }
  end

  rule statics 
    space* "STATIC(" f:static_key_value s:(";" static_key_value)* ")" {
        def value 
          s.elements.inject(f.value) { |h, elt| h.merge!(elt.static_key_value.value) }
        end
    }
  end

  rule binary_key
     hexa ":" key { 
        def value 
            { key.value => hexa.value.to_i(16) }
        end 
    }
  end

  rule integer
    [0-9]+ {
        def value 
            text_value.to_i 
        end 
    }
  end

  rule float
    "-"? integer "." integer {
        def value 
            text_value.to_f 
        end 
    }
  end

  rule hexa
     "0x" [0-9a-fA-F]+ { 
        def value 
            text_value 
        end 
    }
  end
    
  rule boolean
    "true" / "false" {
        def value 
            text_value == "true"
        end 
    }
  end

  # list separator  
  rule spl
    loose_space ";" loose_space
  end

  rule loose_space
    (space / eol)*
  end

  rule space
    (' ' / "\t")+
  end
  
  rule eol
    "\r\n" / "\n" / "\r"
  end

end