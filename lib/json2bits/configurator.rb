# Define a binary serializer using Treetop parser
# Autogenerated from a Treetop grammar. Edits may be lost.


# https://github.com/nathansobo/treetop
# https://www.rubydoc.info/gems/treetop/1.6.11
# https://cjheath.github.io/treetop/
# http://thingsaaronmade.com/blog/a-quick-intro-to-writing-a-parser-using-treetop.html
# https://morioh.com/p/c601072f2066

# see example in fixtures/files/binary_serializer.tt

# External functions
# Device.precondition_vocabulary(attr)

# to compile the grammar
# tt lib/json2bits/configurator.tt -f

#require_relative "codecs"

module Configurator
  include Treetop::Runtime

  def root
    @root ||= :configuration
  end

  module Configuration0
    def line
      elements[0]
    end

  end

  module Configuration1
    def lines
      elements[0]
    end
  end

  module Configuration2
    def value
        lines.elements.inject(Codecs.new) do |codecs, elt| 
          codec = elt.line.value
          codecs.add_codec(codec)
          codecs
        end
    end
  end

  def _nt_configuration
    start_index = index
    if node_cache[:configuration].has_key?(index)
      cached = node_cache[:configuration][index]
      if cached
        node_cache[:configuration][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      i2, s2 = index, []
      r3 = _nt_line
      s2 << r3
      if r3
        r5 = _nt_space
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s2 << r4
        if r4
          s6, i6 = [], index
          loop do
            r7 = _nt_eol
            if r7
              s6 << r7
            else
              break
            end
          end
          if s6.empty?
            @index = i6
            r6 = nil
          else
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          end
          s2 << r6
        end
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(Configuration0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Configuration1)
      r0.extend(Configuration2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:configuration][start_index] = r0

    r0
  end

  module Line0
    def key
      elements[1]
    end

    def space
      elements[2]
    end

    def codec
      elements[3]
    end

    def c
      elements[4]
    end
  end

  module Line1
    def value
      parameters = { 
            key: key.value,
            comment: (c.elements[0] ? c.elements[0].value : "") 
        }
      parameters.merge!(codec.value)
      codec_type = parameters.delete(:codec_type)
      Object.const_get(codec_type).new(**parameters)
    end
  end

  def _nt_line
    start_index = index
    if node_cache[:line].has_key?(index)
      cached = node_cache[:line][index]
      if cached
        node_cache[:line][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_space
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_key
      s0 << r3
      if r3
        r4 = _nt_space
        s0 << r4
        if r4
          r5 = _nt_codec
          s0 << r5
          if r5
            s6, i6 = [], index
            loop do
              r7 = _nt_comment
              if r7
                s6 << r7
              else
                break
              end
            end
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            s0 << r6
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Line0)
      r0.extend(Line1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:line][start_index] = r0

    r0
  end

  module Comment0
  end

  module Comment1
  end

  module Comment2
    def value
      text_value
    end
  end

  def _nt_comment
    start_index = index
    if node_cache[:comment].has_key?(index)
      cached = node_cache[:comment][index]
      if cached
        node_cache[:comment][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_space
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      if (match_len = has_terminal?("//", false, index))
        r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
        @index += match_len
      else
        terminal_parse_failure('"//"')
        r3 = nil
      end
      s0 << r3
      if r3
        s4, i4 = [], index
        loop do
          r5 = _nt_space
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s0 << r4
        if r4
          s6, i6 = [], index
          loop do
            i7, s7 = index, []
            i8 = index
            r9 = _nt_eol
            if r9
              @index = i8
              r8 = nil
            else
              @index = i8
              r8 = instantiate_node(SyntaxNode,input, index...index)
            end
            s7 << r8
            if r8
              if index < input_length
                r10 = true
                @index += 1
              else
                terminal_parse_failure("any character")
                r10 = nil
              end
              s7 << r10
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(Comment0)
            else
              @index = i7
              r7 = nil
            end
            if r7
              s6 << r7
            else
              break
            end
          end
          r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Comment1)
      r0.extend(Comment2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:comment][start_index] = r0

    r0
  end

  def _nt_codec
    start_index = index
    if node_cache[:codec].has_key?(index)
      cached = node_cache[:codec][index]
      if cached
        node_cache[:codec][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_codec_boolean
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_codec_integer
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        r3 = _nt_codec_float
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          r4 = _nt_codec_hexa
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            r5 = _nt_codec_symbol
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r0 = r5
            else
              r6 = _nt_codec_void
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r0 = r6
              else
                r7 = _nt_codec_sequence
                if r7
                  r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                  r0 = r7
                else
                  r8 = _nt_codec_alias
                  if r8
                    r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                    r0 = r8
                  else
                    r9 = _nt_codec_array
                    if r9
                      r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                      r0 = r9
                    else
                      r10 = _nt_codec_xor
                      if r10
                        r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                        r0 = r10
                      else
                        r11 = _nt_codec_list_xor
                        if r11
                          r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                          r0 = r11
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:codec][start_index] = r0

    r0
  end

  module CodecBoolean0
    def value
      {codec_type: "CodecBoolean"} 
    end
  end

  def _nt_codec_boolean
    start_index = index
    if node_cache[:codec_boolean].has_key?(index)
      cached = node_cache[:codec_boolean][index]
      if cached
        node_cache[:codec_boolean][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?("BOOLEAN", false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(CodecBoolean0)
      @index += match_len
    else
      terminal_parse_failure('"BOOLEAN"')
      r0 = nil
    end

    node_cache[:codec_boolean][start_index] = r0

    r0
  end

  module CodecInteger0
    def nb_bit
      elements[2]
    end

  end

  module CodecInteger1
    def value
      {codec_type: "CodecInteger", nb_bit: nb_bit.value} 
    end
  end

  def _nt_codec_integer
    start_index = index
    if node_cache[:codec_integer].has_key?(index)
      cached = node_cache[:codec_integer][index]
      if cached
        node_cache[:codec_integer][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("INTEGER", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"INTEGER"')
      r1 = nil
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?("(", false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure('"("')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_integer
        s0 << r3
        if r3
          if (match_len = has_terminal?(")", false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('")"')
            r4 = nil
          end
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CodecInteger0)
      r0.extend(CodecInteger1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:codec_integer][start_index] = r0

    r0
  end

  module CodecFloat0
    def nb_bit
      elements[2]
    end

    def spl1
      elements[3]
    end

    def min
      elements[4]
    end

    def spl2
      elements[5]
    end

    def max
      elements[6]
    end

  end

  module CodecFloat1
    def value
      {codec_type: "CodecFloat", nb_bit: nb_bit.value, min_float: min.value, max_float: max.value} 
    end
  end

  def _nt_codec_float
    start_index = index
    if node_cache[:codec_float].has_key?(index)
      cached = node_cache[:codec_float][index]
      if cached
        node_cache[:codec_float][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("FLOAT", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"FLOAT"')
      r1 = nil
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?("(", false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure('"("')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_integer
        s0 << r3
        if r3
          r4 = _nt_spl
          s0 << r4
          if r4
            r5 = _nt_float
            s0 << r5
            if r5
              r6 = _nt_spl
              s0 << r6
              if r6
                r7 = _nt_float
                s0 << r7
                if r7
                  if (match_len = has_terminal?(")", false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('")"')
                    r8 = nil
                  end
                  s0 << r8
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CodecFloat0)
      r0.extend(CodecFloat1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:codec_float][start_index] = r0

    r0
  end

  module CodecHexa0
    def nb_bytes
      elements[2]
    end

  end

  module CodecHexa1
    def value
      {codec_type: "CodecHexa", nb_bytes: nb_bytes.value } 
    end
  end

  def _nt_codec_hexa
    start_index = index
    if node_cache[:codec_hexa].has_key?(index)
      cached = node_cache[:codec_hexa][index]
      if cached
        node_cache[:codec_hexa][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("HEXA", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"HEXA"')
      r1 = nil
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?("(", false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure('"("')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_integer
        s0 << r3
        if r3
          if (match_len = has_terminal?(")", false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('")"')
            r4 = nil
          end
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CodecHexa0)
      r0.extend(CodecHexa1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:codec_hexa][start_index] = r0

    r0
  end

  module CodecSymbol0
    def nb_bit
      elements[2]
    end

    def keys
      elements[4]
    end

  end

  module CodecSymbol1
    def value
      {codec_type: "CodecSymbol", nb_bit: nb_bit.value, symbols: keys.value } 
    end
  end

  def _nt_codec_symbol
    start_index = index
    if node_cache[:codec_symbol].has_key?(index)
      cached = node_cache[:codec_symbol][index]
      if cached
        node_cache[:codec_symbol][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("SYMBOL", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"SYMBOL"')
      r1 = nil
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?("(", false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure('"("')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_integer
        s0 << r3
        if r3
          if (match_len = has_terminal?(";", false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('";"')
            r4 = nil
          end
          s0 << r4
          if r4
            r5 = _nt_keys
            s0 << r5
            if r5
              if (match_len = has_terminal?(")", false, index))
                r6 = true
                @index += match_len
              else
                terminal_parse_failure('")"')
                r6 = nil
              end
              s0 << r6
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CodecSymbol0)
      r0.extend(CodecSymbol1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:codec_symbol][start_index] = r0

    r0
  end

  module CodecVoid0
    def value
      {codec_type: "CodecVoid" } 
    end
  end

  def _nt_codec_void
    start_index = index
    if node_cache[:codec_void].has_key?(index)
      cached = node_cache[:codec_void][index]
      if cached
        node_cache[:codec_void][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?("VOID", false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(CodecVoid0)
      @index += match_len
    else
      terminal_parse_failure('"VOID"')
      r0 = nil
    end

    node_cache[:codec_void][start_index] = r0

    r0
  end

  module CodecSequence0
    def keys
      elements[2]
    end

  end

  module CodecSequence1
    def value
      {codec_type: "CodecSequence", keys: keys.value } 
    end
  end

  def _nt_codec_sequence
    start_index = index
    if node_cache[:codec_sequence].has_key?(index)
      cached = node_cache[:codec_sequence][index]
      if cached
        node_cache[:codec_sequence][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("SEQUENCE", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"SEQUENCE"')
      r1 = nil
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?("(", false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure('"("')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_keys
        s0 << r3
        if r3
          if (match_len = has_terminal?(")", false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('")"')
            r4 = nil
          end
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CodecSequence0)
      r0.extend(CodecSequence1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:codec_sequence][start_index] = r0

    r0
  end

  module CodecAlias0
    def key
      elements[2]
    end

  end

  module CodecAlias1
    def value
      {codec_type: "CodecAlias", target_key: key.value } 
    end
  end

  def _nt_codec_alias
    start_index = index
    if node_cache[:codec_alias].has_key?(index)
      cached = node_cache[:codec_alias][index]
      if cached
        node_cache[:codec_alias][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("ALIAS", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"ALIAS"')
      r1 = nil
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?("(", false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure('"("')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_key
        s0 << r3
        if r3
          if (match_len = has_terminal?(")", false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('")"')
            r4 = nil
          end
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CodecAlias0)
      r0.extend(CodecAlias1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:codec_alias][start_index] = r0

    r0
  end

  module CodecArray0
    def nb_bit
      elements[2]
    end

    def spl
      elements[3]
    end

    def item_key
      elements[4]
    end

  end

  module CodecArray1
    def value
      {codec_type: "CodecArray", nb_bit: nb_bit.value, item_key: item_key.value }
    end
  end

  def _nt_codec_array
    start_index = index
    if node_cache[:codec_array].has_key?(index)
      cached = node_cache[:codec_array][index]
      if cached
        node_cache[:codec_array][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("ARRAY", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"ARRAY"')
      r1 = nil
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?("(", false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure('"("')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_integer
        s0 << r3
        if r3
          r4 = _nt_spl
          s0 << r4
          if r4
            r5 = _nt_key
            s0 << r5
            if r5
              if (match_len = has_terminal?(")", false, index))
                r6 = true
                @index += match_len
              else
                terminal_parse_failure('")"')
                r6 = nil
              end
              s0 << r6
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CodecArray0)
      r0.extend(CodecArray1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:codec_array][start_index] = r0

    r0
  end

  module CodecListXor0
    def key
      elements[1]
    end

  end

  module CodecListXor1
    def value
      {
      codec_type: "CodecListXor", 
      key_xor: key.value, 
      }
    end
  end

  def _nt_codec_list_xor
    start_index = index
    if node_cache[:codec_list_xor].has_key?(index)
      cached = node_cache[:codec_list_xor][index]
      if cached
        node_cache[:codec_list_xor][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("LIST_XOR(", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"LIST_XOR("')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_key
      s0 << r2
      if r2
        if (match_len = has_terminal?(")", false, index))
          r3 = true
          @index += match_len
        else
          terminal_parse_failure('")"')
          r3 = nil
        end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CodecListXor0)
      r0.extend(CodecListXor1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:codec_list_xor][start_index] = r0

    r0
  end

  module CodecXor0
    def binary_key
      elements[1]
    end
  end

  module CodecXor1
    def integer
      elements[1]
    end

    def binary_keys
      elements[2]
    end

  end

  module CodecXor2
    def value
      {
        codec_type: "CodecXor", 
        nb_bit_binary_key: integer.value,
        binary_keys: binary_keys.elements.inject({}) { |h, elt| h.merge!(elt.binary_key.value) }
      }
    end
  end

  def _nt_codec_xor
    start_index = index
    if node_cache[:codec_xor].has_key?(index)
      cached = node_cache[:codec_xor][index]
      if cached
        node_cache[:codec_xor][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("XOR(", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"XOR("')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_integer
      s0 << r2
      if r2
        s3, i3 = [], index
        loop do
          i4, s4 = index, []
          if (match_len = has_terminal?(";", false, index))
            r5 = true
            @index += match_len
          else
            terminal_parse_failure('";"')
            r5 = nil
          end
          s4 << r5
          if r5
            r6 = _nt_binary_key
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(CodecXor0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s0 << r3
        if r3
          if (match_len = has_terminal?(")", false, index))
            r7 = true
            @index += match_len
          else
            terminal_parse_failure('")"')
            r7 = nil
          end
          s0 << r7
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CodecXor1)
      r0.extend(CodecXor2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:codec_xor][start_index] = r0

    r0
  end

  module Key0

    def value 
        text_value 
    end
  end

  def _nt_key
    start_index = index
    if node_cache[:key].has_key?(index)
      cached = node_cache[:key][index]
      if cached
        node_cache[:key][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9_]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[a-zA-Z0-9_]')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Key0)
      r0.extend(Key0)
    end

    node_cache[:key][start_index] = r0

    r0
  end

  module Keys0
    def spl
      elements[0]
    end

    def key
      elements[1]
    end
  end

  module Keys1
    def f
      elements[0]
    end

    def s
      elements[1]
    end
  end

  module Keys2
    def value 
        [f.value].concat(s.elements.map { |elt| elt.key.value })
    end
  end

  def _nt_keys
    start_index = index
    if node_cache[:keys].has_key?(index)
      cached = node_cache[:keys][index]
      if cached
        node_cache[:keys][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_key
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_spl
        s3 << r4
        if r4
          r5 = _nt_key
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Keys0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Keys1)
      r0.extend(Keys2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:keys][start_index] = r0

    r0
  end

  module BinaryKey0
    def hexa
      elements[0]
    end

    def key
      elements[2]
    end
  end

  module BinaryKey1

    def value 
        { key.value => hexa.value.to_i(16) }
    end
  end

  def _nt_binary_key
    start_index = index
    if node_cache[:binary_key].has_key?(index)
      cached = node_cache[:binary_key][index]
      if cached
        node_cache[:binary_key][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_hexa
    s0 << r1
    if r1
      if (match_len = has_terminal?(":", false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure('":"')
        r2 = nil
      end
      s0 << r2
      if r2
        r3 = _nt_key
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(BinaryKey0)
      r0.extend(BinaryKey1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:binary_key][start_index] = r0

    r0
  end

  module Integer0
    def value 
        text_value.to_i 
    end
  end

  def _nt_integer
    start_index = index
    if node_cache[:integer].has_key?(index)
      cached = node_cache[:integer][index]
      if cached
        node_cache[:integer][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[0-9]')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Integer0)
      r0.extend(Integer0)
    end

    node_cache[:integer][start_index] = r0

    r0
  end

  module Float0
    def integer1
      elements[1]
    end

    def integer2
      elements[3]
    end
  end

  module Float1
    def value 
        text_value.to_f 
    end
  end

  def _nt_float
    start_index = index
    if node_cache[:float].has_key?(index)
      cached = node_cache[:float][index]
      if cached
        node_cache[:float][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("-", false, index))
      r2 = true
      @index += match_len
    else
      terminal_parse_failure('"-"')
      r2 = nil
    end
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_integer
      s0 << r3
      if r3
        if (match_len = has_terminal?(".", false, index))
          r4 = true
          @index += match_len
        else
          terminal_parse_failure('"."')
          r4 = nil
        end
        s0 << r4
        if r4
          r5 = _nt_integer
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Float0)
      r0.extend(Float1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:float][start_index] = r0

    r0
  end

  module Hexa0
  end

  module Hexa1

    def value 
        text_value 
    end
  end

  def _nt_hexa
    start_index = index
    if node_cache[:hexa].has_key?(index)
      cached = node_cache[:hexa][index]
      if cached
        node_cache[:hexa][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("0x", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"0x"')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?(@regexps[gr = '\A[0-9a-fA-F]'] ||= Regexp.new(gr), :regexp, index)
          r3 = true
          @index += 1
        else
          terminal_parse_failure('[0-9a-fA-F]')
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Hexa0)
      r0.extend(Hexa1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:hexa][start_index] = r0

    r0
  end

  module Spl0
  end

  def _nt_spl
    start_index = index
    if node_cache[:spl].has_key?(index)
      cached = node_cache[:spl][index]
      if cached
        node_cache[:spl][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_space
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?(";", false, index))
        r3 = true
        @index += match_len
      else
        terminal_parse_failure('";"')
        r3 = nil
      end
      s0 << r3
      if r3
        r5 = _nt_space
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Spl0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:spl][start_index] = r0

    r0
  end

  def _nt_space
    start_index = index
    if node_cache[:space].has_key?(index)
      cached = node_cache[:space][index]
      if cached
        node_cache[:space][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if (match_len = has_terminal?(' ', false, index))
        r1 = true
        @index += match_len
      else
        terminal_parse_failure('\' \'')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:space][start_index] = r0

    r0
  end

  def _nt_eol
    start_index = index
    if node_cache[:eol].has_key?(index)
      cached = node_cache[:eol][index]
      if cached
        node_cache[:eol][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if (match_len = has_terminal?("\r\n", false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('"\\r\\n"')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      if (match_len = has_terminal?("\n", false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure('"\\n"')
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        if (match_len = has_terminal?("\r", false, index))
          r3 = true
          @index += match_len
        else
          terminal_parse_failure('"\\r"')
          r3 = nil
        end
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:eol][start_index] = r0

    r0
  end


  class Parser < Treetop::Runtime::CompiledParser
    include Configurator
  end
end

(remove_const(:ConfiguratorParser) if const_defined?(:ConfiguratorParser)) rescue nil; ConfiguratorParser = Configurator::Parser
